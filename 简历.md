# 熟练使用Django web 框架，了解 flask 框架 

# 熟悉服务器间 Socket 通信，熟悉 TCP/IP 等网络协议。

#### socket与TCP/IP的关系

- socket是应用层和传输层之间的一个抽象层
- 它把TCP/IP层的复杂操作抽象为几个简单的接口供应用层调用，从而实现进程在网络之间的通信

#### 什么是socket

`  套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。 `



-  Socket的英文原义是“插座” 。 通常也称作”套接字”，主要用于解决==网络进程间通信。==   

-  两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程。 

  

- 通信
  -  ==本地进程间通信== （PIPE、FIFO、message queue、semaphore、shared memary）可以通过进程ＩＤ唯一标识一个进程。 
  -  ==网络进程通信：==` IP地址+协议+端口号 `唯一标识网络中的一个进程

#### socket（）函数

1. 创建套接字

   ```python
   socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   ```

2. bind()函数： 绑定端口

3. listen（128）：监听，等待客户端连接并设置最大连接数（128）

4. accept（）：建立客户端连接

5. send（）/recv（）：交互

6. close（）：关闭连接

### WebSocket

>  Socket 是传输控制层协议，WebSocket 是应用层协议。 

#####  websocket 跟 socket 的区别 

> 软件通信有七层结构，下三层结构偏向与数据通信，上三层更偏向于数据处理，中间的传输层则是连接上三层与下三层之间的桥梁，每一层都做不同的工作，上层协议依赖与下层协议。基于这个通信结构的概念。
>
> **Socket 其实并不是一个协议，是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。** 当两台主机通信时，让 Socket 去组织数据，以符合指定的协议。TCP 连接则更依靠于底层的 IP 协议，IP 协议的连接则依赖于链路层等更低层次。
>
> WebSocket 则是一个典型的应用层协议。



## TCP 协议/UDP协议

#### TCP

+ TCP是面向连接的通讯协议，通过三次握手建立连接，通讯时完成四次挥手
+ 优点：
  + TCP在数据传输时，有确认，窗口，重传，阻塞等控制机制，能保证数据的正确性，较为可靠

- 缺点：
  - TCP相对于UDP速度慢一点，要求系统资源较

##### **三次握手四次挥手**

> 三次握手：是指在建立一个TCP连接时，需要客户端和服务端总共发送三个包
>
> >  1.第一次握手：客户端发送一个TCP的SYN标志位1的包指明客户端打算连接服务端，并发送初始序号X 
>
> > 2.第二次握手：服务器发回确认包（ACK）应答，即SYN和ACK标志位都为1时，将 确认序号设置为X+1 
>
> > 3.第三次握手：客户端再次发送确认包（ACK）SYN标志位为0，ACK标志位为1，并且把服务器发来ACK的序号字段+1，放在确认字段中发送给服务端 

>四次挥手：TCP的连接拆除需要发送四个包，客户端和服务端均可主动发起挥手动作
>
>> 1.主动方发送Fin+Ack报文，并发送序号X，请求通信关闭
>
>> 2.被动方发送ACK报文，并置发送序号为Z，确认序号为X+1，答应你关闭通信
>
>>  3.被动方发送Fin+Ack报文，并置发送序号为Y，确认序号为X，也请求关闭通信
>
>> 4.主动方发送ack报文，并发送序号为X，确认序号为Y，也答应关闭通信

#### UDP

> UDP是面向无连接的通讯协议， 且不安全的协议，在通信过程中，它并不像TCP那样需要先建立一个连接，只要目的端口号和源端口号确定了， 就能直接发送信息报文，它只提供校验机制来保证报文的完整性，若校验失败，则直接丢报文，不做任何处理。 

+ 优点：
  + 传输速度快，操作简单，要求系统资源少，由于通讯不需要连接，可以实现广播发送
+ 缺点：
  + 由于UDP是无连接的，所有它并不知道接收端是否正确接收，也不重复发送，容易出现丢包现象,不可靠

##### 选择

TCP一般用于文件传输，邮件接发，远程登陆

UDP一般用于在线视频，网络电话













#  熟悉 Python 多线程、多进程、协程的实现原理。。

#### 进程

+ 进程 之间的通信由操作系统传递，导致通讯效率低，切换开销大
+ 密集CPU任务，需要充分利用多核CPU资源（大量并行计算）的时候
  - 缺陷：成本高，开销大

##### 进程之间的通信:

1. 管道：**` 速度慢，容量有限，只有父子进程能通讯`** 
2. FIFO：**` 任何进程间都能通讯，但速度慢`** 
3. 消息队列：**` 容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完的数据的问题`** 
4. 信号量：**` 不能传递复杂消息，只能用来同步`** 
5. 共享内存区：**` 能够很容易控制容量，速度快，但要保持同步`** 
   - 比如一个程序在写的时候，另一个程序要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间的通讯。不过没必要，线程间本来就已经共享了同一进程的一块内存

​	

#### 线程

- 线程分享进程的内存空间，通讯效率高，切换开销小。共享意味着竞争，导致数据不安全，可以引用“互斥锁”

- 而在cpython中，有GIL（全局解释器锁）：

  - 线程执行权限，进程中只有一个GIL

    - 好处：杜绝多个线程访问内存空间的安全问题

    - 坏处：不是真正的多线程，不能充分利用多核CPU的资源

  - 在I/O阻塞时，解释器会释放GIL

- 密集型I/O任务，使用多线程
  - 缺陷：同一时间切片只能运行一个线程，不能做到高并行，但可以做到==高并发==

#### 协程

- 在单线程上执行多个任务，用函数切换，开销极小。
  - genvent, monkey.patchall

- 多线程请求返回是无序的，而协程返回的数据是有序的
- 缺陷：单线程执行，处理密集CPU和本地磁盘I/O时，性能低。处理网络I/O性能高



##  熟练使用MySQL 数据库，熟悉 Redis，MongoDB 等 NoSQL 数据库 

` ‘重要数据：mysql，一般数据：mongodb，临时数据：
memcache’`

#### MongoDB

+  MongoDB 是一个面向文档的数据库系统。以 BSON 结构（二进制）进行存储，对海量数据存储有着很明显的优势。 

```
Monogo 使用C++编写，不支持SQL
BSON 是一种类似于JSON的二进制序列化文档，支持嵌套对象和数组
```

##### 优点

1. **性能优越:快速**！

> 在适量级的内存的 MongoDB ==的性能是非常迅速的==，它将热数据存储在物理内存中，使得热数据的读写变得十分快

2. **高扩展**:

> 第三方支持丰富(这是与其他的 No SQL 相比，MongoDB 也具有的优势)

3. 自身的 **Failover 机制**！ 

   > 故障转移机制： 自动故障切换特性来提供的高可用功能，当主节点成员不可用时从节点成员会自动变成主节点来继续对外提供服务

4. **弱一致性**（最终一致），更能保证用户的访问速度 

5. ** 用于对象及 JSON 数据的存储**

> mongo 的 BSON 数据格 式非常适合文档格式化的存储及查询

6. **内置 GridFS,支持大容量的存储** 

> 高效存储二进制大对象 (比如照片和视频

7. **全索引支持** 

   > 扩展到内部对象和内嵌数组

8. **内置 Sharding** 

>  MongoDB 的 sharding 的特色就是自动化。具体体现为可以动态扩容、自动平衡数据、以及透明的使用接口。可以从一个普通的 replica set，或者单个实例平滑升级，可以动态增加删除节点，响应数据快速增长。可以自动在节点间平衡数据量，避免负载集中在少数节点，而在这期间不影响数据库读写访问。对客户端，可以使用完全相同的驱动，大部分功能可用，基本不需要更改任何代码。 

##### 缺点：

+   MongoDB 不支持事务操作(最主要的缺点)
+   MongoDB 占用空间过大
+   MongoDB 没有如 MySQL 那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方



#### Redis

> 它就是一个不折不扣的内存数据库。

##### Redis 事务

> Redis的事务是一组命令的集合,一个事务的所有命令要么执行,要么都不执行

` multi:开启事务`

` exec:执行事务` 

redis不支持事务的回滚

##### Redis持久化存储

+ 持久化方式:

  > Redis 所有数据都是放在内存中的，持久化是使用 RDB 方式或者 aof 方式。 

- **RDB快照(默认)** 

  ```
  原理：
  	Redis借助了fork命令的copy on write机制。在生成快照试时，将当前进程fork出一个子进程，然后在子进程中循环所有的数据，将数据写成RDB文件，使用redis的save命令调用这个过程
  级别：
  	save 900 1
  	save 300 10
  	save 60 10000
  优点：
  	1.RDB是保存某个时间点的数据集，适用于数据集的备份
  	2.RDB是一个单一文件，方便传输到远端数据中心，适用于灾难回复
  	3.RDB方式可以最大化redis的性能
  缺点：
  	一旦数据库出现问题，RDB文件中保存的数据并不是全新的额，从上次保存到Redis停机这段时间的数据全部丢失
  ```

- **AOF** 

  ```
  原理：
  	对每条写入命令作为日志，以aooend-only模式写入一个日志文件，在redis重启时，可以通过AOF写入的指令来重构整个数据集
  级别：
  	30s 写入一次
  	1s 写入一次
  	每次写操作就写入一次
  优点：
  	1.AOF可以更好的保护数据不丢失，一般每隔1秒执行一次fsync操作，如果redis挂掉，最多丢失1秒的数据
  	2.保存的AOF日志格式文件是按照redis协议的格式保存，易于读取
  缺点：
  	1.速度没有RDB快
  	2.在一个高并发的系统中，命令日志是一个非常庞大的数据，管理维护成本高，恢复重建时间会非常长
  	
  ```


- **` 选择` ** 

  RDB + AOF：综合使用两种持久化方式，用AOF保证数据不丢失，作为恢复数据的第一选择；用RDB来做冷备份，在AOF文件丢失或不可用的时候，用RDB进行快速的数据恢复

##### **优点**

```python
1 读写性能优异 
2 支持数据持久化，支持 'AOF' 和 'RDB' 两种持久化方式 
3 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。
4 数据结构丰富：除了支持 string 类型的 value 外还支持 string、hash、set、sortedset、list 等数据结构。
```

##### **缺点**

```python
1 Redis' 不具备自动容错和恢复功能'，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。 
2 '主机宕机'，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，'降低了系统的可用性'。 
3 Redis的'主从复制采用全量复制'，复制过程中主机会'fork '出一个子进程对内存做一份快照，并将子进程的内存快照保存 为文件发送给从机，这一过程需要确保主机有足够多的空余内 存。若快照文件较大，对集群的服务能力会产生较大的影响， 而且复制过程是在从机新加入集群或者从机和主机网络断开重 连时都会进行，也就是网络波动都会造成主机和从机间的一次 全量的数据复制，这对实际的系统运营造成了不小的'麻烦'。 
4 'Redis 较难支持在线扩容'，在集群容量达到上限时在线 扩容会变得很复杂。为避免这一问题，运维人员在系统上线时 必须确保有足够的空间，这对资源造成了很大的浪费。
```

### Redis/Mongodb

```python
1. MongoDB 和 Redis 都是 NoSQL，采用结构型数据存储。
2. 二者在使用场景中，存在一定的区别，这也主要由于二者在内存 映射的处理过程，持久化的处理方法不同。
3. MongoDB 建议'集群 '部署，更多的考虑到集群方案，
4. Redis 更偏重于进程顺序写入， 虽然支持集群，也'仅限'于'主-从模式'
```

#### MongoDB 和 Redis 的区别：

+ ###### 集群

  + MongoDB 集群技术比较成熟，Redis从3.0开始支持集群。 

+ ###### 内存管理机制

  + Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据。
  + MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘。


  + ###### 支持的数据结构

    + Redis 支持的数据结构丰富，包括hash、set、list等。
    + MongoDB 数据结构比较单一（K-V），但是支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富。


  + ###### 不适用的场景

    Ø  需要使用复杂sql的操作

     Ø  事务性系统 



### MySQL

##### MySQL的引擎

+  InnoDB和MyISAM是MySQL的存储引擎 
+  区别 

```tex
1.InnoDB支持事务,MyISAM不支持,对于InnoDB每一条SQL语言都默认封装成事务,自动提交,这样会影响速度,所以最好把多条SQL语言放在begin和commit之间,组成一个事务；
2.InnoDB支持外键,而MyISAM不支持.对一个包含外键的InnoDB表转为MYISAM会失败；
3.InnoDB是聚集索引,数据文件是和索引绑在一起的,必须要有主键,通过主键索引效率很高.但是辅助索引需要两次查询,先查询到主键,然后再通过主键查询到数据.因此,主键不应该过大,因为主键太大,其他索引也都会很大.而MyISAM是非聚集索引,数据文件是分离的,索引保存的是数据文件的指针.主键索引和辅助索引是独立的.
4.InnoDB不保存表的具体行数,执行select count(*) from table时需要全表扫描.而MyISAM用一个变量保存了整个表的行数,执行上述语句时只需要读出该变量即可,速度很快；
5.Innodb不支持全文索引,而MyISAM支持全文索引,查询效率上MyISAM要高；
6.MySQL5.6版本InnoDB已支持全文索引
```

- 选择

  ```tex
  1.是否要支持事务,如果要请选择innodb,如果不需要可以考虑MyISAM；
  2.如果表中绝大多数都只是读查询,可以考虑MyISAM,如果既有读写也挺频繁,请使用InnoDB.
  3.系统奔溃后,MyISAM恢复起来更困难,能否接受；
  4.MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM),说明其优势是有目共睹的,如果你不知道用什么,那就用InnoDB,至少不会差.
  ```

- 总结

  - 读操作多用MyISAM
  - 写操作多用InnoDB

##### 复制集和分布式

- 复制集：搭建主从数据库
  - 目的：
    - 数据库的数据相同，起到备份的作用
    - 高可用——HA ： 提高稳定性
    - 数据库的读写分离：**写操作涉及到锁的问题，不管是行锁还是表锁还是块锁，都是比较降低系统执行效率的事情。我们这样的分离是把写操作集中在一个节点上，而读操作其他的N个节点上进行，从另一个方面有效的提高了读的效率，保证了系统的高可用性**。
- 分布式：数据库的数据不同， 每部分的数据共同组成完整的数据集合
  - 每个节点被称为一个节点
  - 高吞吐（提高查询效率）
- 复制集和分布式可单独使用，也可组合使用，组合使用时，分布式的每个分片都是主，复制集的是从

##### MySQL主从复制原理

- master将改变记录到二进制日志（binary log)中，
- slave将master的binary log events拷贝到他的中继日志（relay log)
- SQL线程从中继日志中读取事件，更新slave的数据



##### MySQL数据库事务

###### **事务具有ACID的特性：**

> 1. 原子性  2. 一致性  3. 隔离性   4. 持久性

1. **原子性(atomicity)**:事务中的所有操作是不可分割的，要么全部提交成功，要么全部失败回滚。

2. **一致性(consistency)**:数据库总是从一个一致性状态转换到另一个一致性状态。

3. **隔离性(isolation)** :一个事务所做的修改在提交之前对其它事务是不可见的。

4. **持久性(durability)**:一旦事务提交，其所做的修改便会永久保存在数据库中。

###### 事务隔离的四个级别

- **Read Uncommitted:** ` 读取未提交, 隔离级别最低的一个事务级别.一个事务会读取到另一个事务更改后未提交的数据，当事务回滚后，这个事务读到的数据就是脏数据，称为脏读` 
- **Read Committed**:`  读取已提交：该隔离级别下，一个事务会遇到不可重复读的问题。 `

```
不可重复读：A事务内，需要多次读取同一个数据，同时，B事务修改了该数据，那么，A事务多次读取的数据可能不一致。虽然解决了脏读的问题，未提交之前数据不变，但是当A事务在不知道B事务的存在下，有可能两次读的数据不同，所以正确的就是只读一次，不要多次读取。
```

- **Repeatable Read:** `  可重复读：该隔离级别下，不管是否提交，一个事务不会读到另一个事务的更改，每次都是读取的原始数。但是会出现幻读问题 ` 
- **Serializable:** `  串行执行事务：最高级别的隔离，所有事务依次执行，避免了脏读和可重复读，但是降低了效率和程序性能 `

##### 读写分离对事务的影响

- 对于写操作，因为事务是单机的（不能跨服务器），所以开启事务和提交或回滚分散到不同服务器就会失效
- 对于包含读写操作时：与事务的隔离级别相关，可重复度有影响；其他没有影响。



##### 分布式ID--唯一的id

- Redis的inrc和inrcby
- ==雪花算法==



##### 索引的底层原理

- 建立底层平衡的搜索二叉树（大多数B树）左儿子始终小于老子；右儿子始终大于老子。

- 索引提高了查询速度，但是会影响增删改的速度：

  ```
  当新增数据影响到二叉树的平衡时，二叉树需要重新调整结构，这个过程性能消耗大，所以速度慢
  ```

  



##### MySQL性能优化方法

- 按照三范式设计表
- 设计表时，考虑到有些字段为了方便查询，而采用空间换取时间的方法，适当增加冗余字段（反范式设计）
- 建立索引
- sql语句优化
  - 使用索引遵循最左原则
  - 不要 select * , 只查询要查询的字段
  - 尽量不使用联合查询
  - 普通查询 > 联合查询 > 子查询
  - SQL语句尽量大写
  - 选择恰当的数据类型，如整型的选择； VARCHAR
  - 对于强调快速读取的操作，可以考虑使用MyISAM数据库引擎；
  - 对于模糊 like 查询 将导致全表扫描，应避免使用
- 内存型数据库：mysql + redis
- 配置主从，读写分离







#  熟悉爬虫过程，掌握使用 Requests 包爬虫技术。 





##  掌握Docker 的基本使用，熟悉 linux 常用命令并能进行简单的 shell 编程， 日常能够在 Linux 环境下进行开发。

### Docker

+ ###### 什么是Docker

  + 开源的应用容器引擎, 基于 [Go 语言](https://www.runoob.com/go/go-tutorial.html) 并遵从Apache2.0协议开源 
  + docker 重新定义了程序开发测试，交付和部署过程的开放平台。
  + docker可以保持开发，测试和生产环节高度一致

+ docker 利用了namespace 来做权限的控制和隔离， cgroups 进行资源的配置，通过 aufs 进一步提高文件系统的资源了利用率

+ 相对于VM，优势：

  + 启动速度快
  + 资源利用率高
  + 性能开销小